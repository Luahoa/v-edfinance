# Test Environment & Data Management Guide

## 1. Strategy: Isolation & Parity
To eliminate "blind spots," we ensure the test environment mimics Production using Docker-based parity.

### A. Environment Architecture
- **Local Dev**: Uses `docker-compose.yml` (Postgres 15-alpine).
- **CI/Stage**: Uses `docker-compose.test.yml` with isolated networks.
- **Production**: Cloudflare Pages + Dokploy VPS.

## 2. Test Data Management (TDM)
We avoid "dirty data" by using a three-tier seeding strategy:

### Tier 1: System Seeds (Static)
Required for the app to run (Locales, SystemSettings, Initial Courses).
`npx prisma db seed`

### Tier 2: Scenario Mocks (Dynamic)
Generated by the [DiagnosticService](file:///c%3A/Users/luaho/Demo%20project/v-edfinance/apps/api/src/modules/debug/diagnostic.service.ts) using the **Mock Behavioral Data Generator**.
- `/api/debug/diagnostics/mock-behaviors` (Generates logs, streaks, and engagement data).

### Tier 3: Edge Case Data
Specific datasets for testing failure modes (Invalid JSONB, expired tokens, empty portfolios).

## 3. Implementation: docker-compose.test.yml
```yaml
services:
  test-db:
    image: postgres:15-alpine
    container_name: vedfinance-test-db
    environment:
      POSTGRES_USER: test_user
      POSTGRES_PASSWORD: test_password
      POSTGRES_DB: vedfinance_test
    ports:
      - "5434:5432"
```

## 4. Maintenance Protocol
1. **Fresh Start**: Before every full test run, the DB is reset: `prisma migrate reset --force`.
2. **Schema Audit**: Every test run starts with `DiagnosticService.checkIntegrity()` to catch schema drift before testing logic.
3. **Log Slicing**: CI logs are tagged with `ErrorId` for instant correlation if a test fails.
